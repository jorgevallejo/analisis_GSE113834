---
title: "Análisis de datos de expresión de la serie GSE113834"
subtitle: "Análisis Datos Ómicos - PEC 1"
author: "Jorge Vallejo Ortega"
date: '`r format(Sys.Date(),"%e de %B, %Y")`'
output:
  html_document:
    toc: true
  pdf_document:
      toc: true
# Next code for knitting both types of documents automatically comes from https://stackoverflow.com/questions/39662365/knit-one-markdown-file-to-two-output-files/53280491#53280491
knit: (function(inputFile, encoding) {
  rmarkdown::render(inputFile, encoding = encoding,
  output_format = "all",
  output_dir = "results") })
# And:
# https://stackoverflow.com/a/46007686/10647267

---

```{r setup, include=FALSE}
# knitr options

# Do not display code in output document
knitr::opts_chunk$set(echo = FALSE)

# This is a try:
knitr::opts_knit$set(stop_on_error = 2L)
# See ?evaluate::evaluate
# What I am trying to do is to make knitr stop
# when an error is found instead of running the
# complete script.
```

# Abstract

XXX Falta por incluir XXX

```{r estructura de directorios}
# Directory for raw data
if (!(dir.exists("data"))){
dir.create("data")
}
# Directory for results
if (!(dir.exists("results"))){
  dir.create("results")
}
# Directory for processed data
if (!(dir.exists("intermediateResults"))){
  dir.create("intermediateResults")
}
```

# Objetivos

El objetivo, dentro del trabajo original XXX insertar referencia XXX, es estudiar el acortamiento (deadenilación) de la cola poli-A en ARNm de genes asociados al riesgo de desarrollar trastorno del espectro autista ("autism spectrum disorder", ASD).

Mi objetivo en este análisis es, a partir de los datos de expresión detectados por las microarrays, extraer un listado de genes cuyos ARNm contengan una cola poli-A más larga, o más corta, al comparar muestras de sujetos control con muestras de sujetos con ASD. Una vez obtenido el listado, el objetivo final es averiguar qué términos de la ontología génica están significativamente enriquecidos en esa lista de genes.

# Materiales y métodos

## Muestras y datos de origen
El material biológico de partida fueron muestras post-mórtem de córtex prefrontal de pacientes con trastorno del espectro autista (n = 5) y de controles (n = 4), todos ellos varones de 5-23 años de edad. A partir de las muestras de tejido se extrajo el ARN total. De cada muestra de ARN total se guardó una alíquota ("Input"), y el resto se separó por cromatografía en un fracción enriquecida en ARNm con colas poli-A largas ("Wash") y otra enriquecida en ARNm con colas poli-A cortas ("Eluted"). Las muestras de ARN fueron traducidas a ADNc, y este amplificado.

Las muestras de ADNc fueron hibridadas en arrays GeneChip Human PrimeView (Affymetrix, 901838); estos fueron leídos en un GeneChip Scanner GCS3000 (Affymetrix), y mediante Command Console (Affymetrix) los datos se almacenaron en archivos CEL. Estos archivos CEL, descargados desde XXX referencia a la web en GEO XXX han sido la base para el presente análisis. Los datos usados en la anotación de los resultados proceden de XXX enlace al archivo GPL XXX.

## Diseño experimental

El conjunto de 27 ficheros CEL (cada uno procedente de una microarray) se puede clasificar según la condición del sujeto de origen ("Control" o "ASD"), y según el enriquecimiento en diferentes longitudes de colas poli-A en los ARNm ("Input", "Wash", o "Eluted").

Por combinación de ambas variables podemos dividir las muestras en seis grupos experimentales:
Control-Input
Control-Wash
Control-Eluted

ASD-Input
ASD-Wash
ASD-Eluted

Las muestras "Input" contienen el ARN total. Si comparamos las muestras Control-Input con las muestras ASD-Input, comprobaremos si podemos detectar expresión diferencial entre las condiciones Control y ASD.

Las muestras "Wash" están enriquecidas en ARN de cola poli-A corta, y las muestras "Eluted" en ARN de cola poli-A larga. Podemos hacer las siguientes comparaciones:
Control-Wash vs Control-Eluted: Qué genes se transcriben a ARN de diferentes longitudes de cola poli-A en sujetos Control.

ASD-Wash vs ASD-Eluted: Qué genes se transcriben a ARN de diferentes longitudes de cola poli-A en sujetos Control.

Comparando los listados de genes de las dos comparaciones anteriores obtendremos un listado de los genes que se comportan de forma diferente en sujetos Control y sujetos ASD con respecto a las colas poli-A de sus ARN.

## Procedimiento seguido en el análisis

Los pasos seguidos para realizar el presente análisis han sido los siguientes:
1. Obtenión de los datos de expresión en bruto.
2. Control de calidad de los datos brutos.
3. Normalización.
4. Control de calidad de los datos normalizados.
5. Filtraje no específico.
6. Identificación de genes diferencialmente expresados.
7. Anotación de los resultados.
8. Comparación entre comparaciones.
9. Análisis del enriquecimiento de rutas.

### Obtención de los datos en bruto

Los datos en bruto usados en el análisis ha sido descargados de Gene Expression Omnibus, un repositorio público de datos de genómica funcional, donde los datos están catalogados bajo el código de acceso GSE113834 XXX inserta enlace XXX.

Los datos de expresión han sido descargados de dicho repositorio en forma de ficheros CEL.

La relación entre cada fichero y el grupo experimental al que pertenece se ha extraido de la tabla "Samples", accesible en la misma página web que los ficheros CEL.

Los datos de anotación correspondientes al modelo de array usado, están catalogados en el repositorio GEO bajo el código de acceso GPL15207 XXX insertar enlace XXX. Dichos datos han sido descargados en forma de fichero de texto, y usados para anotar los datos obtenidos de las sondas de las arrays.

```{r prepare data from CEL files, eval=FALSE}
GSE_address <- "https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE113834"
data_origin <- "https://www.ncbi.nlm.nih.gov/geo/download/?acc=GSE113834&format=file"
gpl_origin <- "https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?mode=raw&is_datatable=true&acc=GPL15207&id=17536&db=GeoDb_blob169"

# De-compress files
cel_tar <- "data/GSE113834_RAW.tar"
untar(cel_tar, exdir = "data")
file.remove(cel_tar)
zip_files <- dir("data")
sapply(zip_files, function(x){
  system2("gunzip",
          args = c("-d", paste0("data/", x)))
  })
```
```{r generate targets file}
# Generate targets file
# initial_target_file.csv is a copy-paste of the samples/group table
# from the GSE webpage to LibreOffice Calc and saved as a csv file.
targets <- read.csv2("data/initial_target_file.csv", header = FALSE, stringsAsFactors = FALSE)
# Remove trailing spaces in sample names
targets$V1 <- sub("[[:blank:]]", "", targets$V1)
# Add Condition column
targets$Condicion <- as.factor(sub("-[[:print:]]+", "", targets[,2]))
# Add Material column
targets$Material <- as.factor(sub("[[:graph:]]+[[:blank:]]", "", targets[,2]))
# Add Group column. Sep is a dot to make syntactically valid names
targets$Grupo <- as.factor(paste(targets$Condicion, targets$Material, sep="."))
# Rearrange columns
targets <- targets[, c(1, 5, 3, 4, 2)]
# Change column names
colnames(targets)[c(1, 5)] <- c("Archivo", "Abreviado")
# Write final targets file
write.csv2(targets, file = "intermediateResults/targets2.csv", row.names = FALSE)
```


```{r delete results files, eval= FALSE}
# Run this chunk ONLY if you want to re-do
# all the report FROM ZERO.
# Remember that the .RData files are there to
# avoid unnecesarily redoing of long data processing.

file.remove(c("./intermediateResults/dist_matrix.RData",
              "./intermediateResults/gse.RData",
              "./intermediateResults/Pset.RData",
              "./intermediateResults/targets2.csv"))


```


```{r libraries, include=FALSE}
# Install packages
# Load packages
# ...

library(knitr)

```

```{r construct targets file, eval=FALSE}
# List of CEL files
library('oligo')
celFiles <- list.celfiles("data", full.names=TRUE)
# Generate phenoData
library(Biobase)
my.targets <- read.AnnotatedDataFrame(file.path("intermediateResults", "targets2.csv"), header = TRUE, row.names=1, sep = ";")
```

```{r ExpressionSet con affy}
# This is the only method for generating an ExpressionSet object
# that didn't gave me problems.
# In fact, it is an AffyBatch object, not a pure ExpresionSet.
library(affy)
rawData <- read.affybatch(filenames = celFiles,
                          phenoData = my.targets)
```

Los diferentes archivos con los datos en bruto han sido manipulados utilizando R para realizar los controles de calidad y los análisis propiamente dichos. El código completo usado puede consultarse en el apéndice. XXX modifica párrafo según sea necesario XXX

### Control de calidad de los datos en bruto
Con el control de calidad pretendemos averiguar si los datos de alguna de las muestras presentan defectos o sesgos que desaconsejen usarlos, antes de continuar con el análisis.

En este caso hemos usado examinado los datos de expresión mediante diferenes representaciones gráficas, en busca de anomalías.

XXX Si finalmente no usas el paquete ArrayQualityMetrics, elimina esta parte XXX
En esta ocasión usaremos el paquete de análisis ArrayQualityMetrics.

```{r control de calidad con ArrayQualityMetrics, eval=FALSE}
library(arrayQualityMetrics)
arrayQualityMetrics(rawData)
```

```{r re-used variables}
# Labels for each sample
array_labels <- noquote(pData(rawData)$X.Abreviado.)
# Common colour pattern for the graphs
graph_colours <- rainbow(length(array_labels))
```


#### Gráficos de densidad

Los gráficos de densidad nos informan acerca de la forma y posición de las señales sin normalizar.

```{r grafico de densidad}
hist(rawData, col = graph_colours,
     main="Densidad de la señal en bruto",
     ylab="Densidad", xlab= "log Intensidad")

legend(x=11.9, y=0.31, legend=array_labels, 
       fill=graph_colours, ncol=2, bty="n", cex=0.5)
```

Este caso vemos que la curva de densidad es similar en todas las muestras, sin mostrar grandes diferencias.

#### Diagrama de cajas

El gráfico de diagrama de cajas nos permite comparar la distribución de la intensidad entre las diferentes muestras.

```{r boxplot}
boxplot(rawData,
        names=array_labels,
        cex.axis=0.5, las=2, which="both",
        col = graph_colours,
        main="Distribución de valores de intensidad en bruto")
```

Podemos ver que ninguna de las muestras destaca entre el resto. Hay pequeñas variaciones, pero es una característica esperable cuando comparamos los datos de intensidad en bruto.

#### Dendrograma del clúster jerárquico

El dendrograma nos ayuda a representar cómo se agrupan las muestras, y da pistas acerca de cuál es el factor experimental que determina las diferencias entre muestras. Aquellas muestras con datos más similares aparecerán agrupadas.

```{r dendrograma, fig.height=5, fig.width=8}
# Calcular matriz de distancias
if(file.exists("intermediateResults/dist_matrix.RData")){
  load("intermediateResults/dist_matrix.RData")
  }else{
    dist_matrix <- dist(t(exprs(rawData)))
    save(dist_matrix, file = "intermediateResults/dist_matrix.RData")
  }
# Cambia el atributo 'Labels' con los nombres abreviados de las muestras.
attr(dist_matrix, "Labels")<- array_labels

hier_clust <- hclust(dist_matrix, "average")

plot(hier_clust, main="Dendrograma de datos muestrales en bruto",
     hang = -1, cex = 0.66, xlab= "Muestras", sub="", ylab = "", yaxt="n")
```

En este caso, y a primera vista, no parece haber un factor claro que haga que unas muestras están más cercanas entre sí que otras. Quizá el material (input/wash/eluted) en primer lugar, y el grupo (ctrl/asd) en segundo lugar; pero no es definitivo.

#### Componentes principales

El análisis de componentes principales nos puede servir para detectar si las muestras se agrupan con otras muestras procedentes del mismo grupo, o si no hay correspondencia entre muestras del mismo grupo.

```{r funcion plotPCA3}

# Función para visualización de componentes principales
# Código adaptado de Statistical Analysis of Microarray data (adapted for teaching purposes) Based on Gonzalo, Ricardo and Sanchez-Pla, Alex (2019)

 library(ggplot2)
 library(ggrepel)
 plotPCA3 <- function (datos, labels, factor, title, scale,colores, size = 1.5, glineas = 0.25) {
   data <- prcomp(t(datos),scale=scale)
   # plot adjustments
   dataDf <- data.frame(data$x)
   Group <- factor
   loads <- round(data$sdev^2/sum(data$sdev^2)*100,1)
   # main plot
   p1 <- ggplot(dataDf,aes(x=PC1, y=PC2)) +
     theme_classic() +
     geom_hline(yintercept = 0, color = "gray70") +
     geom_vline(xintercept = 0, color = "gray70") +
     geom_point(aes(color = Group), alpha = 0.55, size = 3) +
     coord_cartesian(xlim = c(min(data$x[,1])-5,max(data$x[,1])+5)) +
     scale_fill_discrete(name = "Grupo")
   # avoiding labels superposition
   p1 + geom_text_repel(aes(y = PC2 + 0.25, label = labels),segment.size = 0.25, size = size) + 
     labs(x = c(paste("PC1",loads[1],"%")),y=c(paste("PC2",loads[2],"%"))) +  
     ggtitle(paste("Análisis de componentes principales para: ",title,sep=" "))+ 
     theme(plot.title = element_text(hjust = 0.5)) +
     scale_color_manual(values=colores)
 }
```

```{r componentes ppales}
plotPCA3(exprs(rawData), labels = array_labels,
         factor = pData(rawData)$X.Grupo, title="Datos brutos",
         scale = FALSE, size = 3, colores = rainbow(6))
```

De forma similar a lo que veíamos en el dendrograma, las diferencias más importantes entre las muestras parecen deberse al material antes que al grupo.

La componente más importante explica el 67.7% de la variabilidad total de las muestras, y parece deberse principalmente al material; las muestras "Wash" se agrupan más a la izquierda, compartiendo la zona central con las muestras "Input", y las muestras "Eluted" agrupadas hacia la derecha del gráfico.

La muestra "CTRL-1 INPUT" aparece alejada, no sólo de las otras muestras del grupo CTRL-INPUT, sino de todo el resto de muestras. Esto por sí sólo no significa que la muestra sea defectuosa, pero sí que deberíamos fijarnos en ella y comprobar qué resultados obtiene en el resto de gráficos.

#### Imagen del array

Examinar la imagen del array nos permite hacer una evaluación de calidad a nivel "macro". Nos permite hacer una estimación a ojo de características como el balance del color, la uniformidad en la hibridación y en los spots, si el background es mayor de lo normal y la existencia de artefactos como el polvo o pequeñas marcas (rasguños).


```{r array image, fig.height=32, fig.width=12}
#pseudo image of the weights for the first arrays in the dataset
par(mfrow=c(9,3))
for (num in 1:length(array_labels)){
  image(rawData[, num], main = array_labels[num])
}
```

A simple vista no se observa ningún gran defecto como roturas, burbujas o manchas.

En ninguna de las gráficas hemos encontrado señales que nos hagan desconfiar de la calidad de ninguna de las muestras. La única excepción podría ser la muestra "CTRL-1 INPUT" en la gráfica de componentes principales; pero en el resto de gráficas no destaca de ninguna forma, así que la incluiremos con las demás en el resto del análisis.

## Normalización de los datos

Antes de empezar el análisis de expresión es necesario procesar los datos brutos de forma que los datos de las diferentes muestras (micorarrays) sean comparables. El proceso de normalización intenta asegurarse de que las diferencias de intensidad reflejen la expresión diferencial de los genes, eliminando sesgos producidos por razones técnicas.

El método de normalización que hemos usado en este análisis es el método RMA (_robust multi-array average_), que es uno de los más usados en el ecosistema de Bioconductor.

```{r normalizacion RMA}
# First checks if the expressionset has been already calculated and saved
eset_rma_file <- file.path("intermediateResults", "eset_rma.RData")

if(file.exists(eset_rma_file)){
  load(eset_rma_file)
}else{
  eset_rma <- affy::rma(rawData)
  save(eset_rma, file = eset_rma_file)
}
```

## Control de calidad sobre datos normalizados

Después de la normalización volvemos a realizar un control de calidad, para comprobar que el resultado de la normalización ha producido el efecto esperado en la distribución de los datos.

### Diagrama de cajas

Con gráfico de diagrama de cajas volvemos a comparar la distribución de la intensidad entre las diferentes muestras.

```{r boxplot datos normalizados}
boxplot(eset_rma,
        names=array_labels,
        cex.axis=0.5, las=2,
        col = graph_colours,
        main="Distribución de valores de intensidad normalizados (RMA)")
```

Si lo comparamos con el gráfico de antes de normalizar, en éste la distribución de intensidades es mucho más uniforme entre muestras.

#### Componentes principales

El análisis de componentes principales nos puede servir para detectar si las muestras se agrupan con otras muestras procedentes del mismo grupo o si no hay correspondencia entre muestras del mismo grupo.

```{r componentes ppales datos normalizados}
# Expression data from eset_rma will be used several times along the code
exprs_eset_rma <- exprs(eset_rma)

plotPCA3(exprs_eset_rma, labels = array_labels,
         factor = pData(eset_rma)$X.Grupo, title="Datos normalizados",
         scale = FALSE, size = 3, colores = rainbow(6))
```

Ahora el primer componente es responsable del 37% de la variabilidad total. Casi la mitad de lo que ocurría al utilizar los datos brutos. Las muestras se siguen separando según material, con "Input" en el centro, igual que antes; las muestras "Eluted" a un lado y las muestras "Wash" al otro.

La variabilidad explicada por la componente secundaria es el 16%, y también parece depender del material; separando claramente "INPUT" de los otros dos materiales ("ELUTED" y "WASH"). El grupo sin embargo - "CTRL" frente a "ASD" -, no parece tener una gran influencia en la variabilidad.

Un cambio notable en el diagrama de componentes es prinpales es la posición de la muestra "CTRL-1 INPUT", que ya no aparece separada del resto como sí ocurría al utilizar los datos brutos.

En conclusión, podríamos decir que la normalización de los datos ha producido el efecto esperado y no encontramos impedimento para proceder al análisis de los datos.

## Filtraje no específico

Antes del análisis estadístico, para eliminar ruido y mejorar la sensibilidad, hemos eliminado datos procedentes de sondas que no aportan información o que pueden aportar información duplicada o confuso.

En concreto, se han eliminado datos de las siguientes sondas: Sondas cuya función específica es el control de calidad de las arrays y no se corresponden a genes, sondas para las que no se dispone de anotación, sondas duplicadas (diferentes sondas que corresponden al mismo gen)[^1], y sondas que corresponden a más de un gen[^2].

Después de esa primera selección hemos excluido también aquellas sondas con menor variabilidad de datos entre muestras[^3]. Esto se ha hecho así porque no se espera que genes con poca variabilidad entre muestras presenten expresión diferencial, y reducir la cantidad de genes a examinar aumentará la sensibilidad del análisis.

```{r read GPL15207 table}
# This chunk reads the GPL15207 data from the file
# data/GPL15207-17536.txt
# Such file has been previously downloaded from the
# address stored in the variable gpl_origin
gpl_table_file <- "intermediateResults/gpl_table.RData"

if(file.exists(gpl_table_file)){
  load(gpl_table_file)
}else{
  # Read the lines of the file
  gpl_text <- readLines("data/GPL15207-17536.txt")
  # Identify the line just before the headers line
  # This will be used as the starting point for read.table()
  start_row <- grep("#SPOT_ID =", gpl_text)

  gpl_table <- read.table("data/GPL15207-17536.txt", sep = "\t",
                        skip = start_row,
                        # In the GPL table NA values are codified as "---"
                        na.strings = "---",
                        colClasses = "character", 
                        stringsAsFactors = FALSE,
                        header = TRUE, fill = TRUE,
                        quote="", comment.char = "")
  save(gpl_table, file = gpl_table_file)
}

# Create table with probeID and EntrezID
gpl_entrezid <- gpl_table[,c("ID", "Entrez.Gene")]
```

```{r filtraje a mano}
# Make a dataframe combining probeID, IQR, and EntrezID
IQR_set <- apply(exprs_eset_rma, 1, IQR)
IQR_dataframe <- as.data.frame(IQR_set)
colnames(IQR_dataframe) <- c("IQR")
IQR_combined <- merge(IQR_dataframe, gpl_entrezid,
                      by.x = 0, by.y = "ID")

# Filter out Affymetrix QC probes
QCprobes <- grep("^AFF", IQR_combined$Row.names)
IQR_noprobes <- IQR_combined[-QCprobes, ]
# Filter out probes without Entrez ID
    # Vector with the indexes of NA in column Entrez.Gene
no_entrez <- which(is.na(IQR_noprobes$Entrez.Gene) == TRUE)
IQR_no_entrez <- IQR_noprobes[-no_entrez, ]
# Nevertheless, I know that there are probes that map to
# two or more different EntrezIDs. I don't know how to
# handle those cases.
```



```{r sondas para el mismo codigo Entrez}
# Order files (descendant) for entrezId, then for IQR
ordered_IQR <- IQR_no_entrez[ order(IQR_no_entrez$Entrez.Gene, 
                                   -IQR_no_entrez$IQR), ]
# Make logical vector of duplicates
dup_entrez <- duplicated(ordered_IQR$Entrez.Gene)
dup_rows <- which(dup_entrez == TRUE)
nondup_probes <- ordered_IQR[-dup_rows, ]
```

```{r sondas con varios codigos Entrez}
# Detect which values in column Entrez.Gene contain more than one code
multGenes <- grep("/", nondup_probes$Entrez.Gene, value = FALSE)
# Filter out rows with multiple entrez IDs
nondup_probes <- nondup_probes[-multGenes, ]
```


```{r filtraje por IQR}
# Elimina las sondas cuyo rango interquantil (IQR) sea menor a la mediana
# de todos los IQR.
median_IQR <- median(nondup_probes$IQR)
filtered_probes <- nondup_probes[nondup_probes$IQR > median_IQR, ]
```

Número inicial de sondas: `r format(nrow(exprs_eset_rma), big.mark= " ")`

Sondas de control de calidad: `r length(QCprobes)`
Sondas sin anotación: `r length(no_entrez)`
Sondas duplicadas: `r sum(dup_entrez)`
Sondas que corresponden a más de un gen:`r format(length(multGenes), big.mark=" ")`
Sondas excluidas por baja variabilidad: `r format(nrow(nondup_probes)-nrow(filtered_probes), big.mark= " ")`

Número de sondas para siguientes análisis: `r format(nrow(filtered_probes), big.mark= " ")`

```{r modify eset_rma with filtered data}
# Merge filtered probes with expression data
eset_filtered <- merge(exprs_eset_rma, filtered_probes$Row.names,by.x = 0, by.y = 1)
row.names(eset_filtered) <- eset_filtered$Row.names
eset_filtered$Row.names <- NULL

save(eset_filtered, file="intermediateResults/eset_filtered.RData")

# Modify eset expr with filtered data
# filtered_exprs_matrix <- as.matrix(filtered_exprs)
# exprs(eset_rma) <- filtered_exprs_matrix
## No puedo o no se como hacerlo
```

## Identificación de genes diferencialmente expresados

Para el análisis de este ensayo, consideramos una matriz de diseño siguiendo un modelo de un factor con seis niveles, siendo esos niveles los grupos a los que está asignada cada muestra:
`r unique(targets$Grupo)`

```{r matriz de diseño}
library(limma)
designMat <- model.matrix(~0+targets$Grupo)
colnames(designMat) <- levels(targets$Grupo)
rownames(designMat) <- targets$Abreviado
```

Para cumplir con el objetivo del estudio, el interés entá en averiguar qué genes presentan cambios significativos entre las muestras "Wash" y las muestras "Eluted". Y además, si esos cambios significativos se mantienen entre los grupos "Control" y "ASD".

Para replicar ese razonamiento, hemos organizado los siguientes contrastes:

WASH vs ELUTED en sujetos CONTROL
WASH vs ELUTED en sujetos ASD

También podría valer la pena comprobar si hay interacción entre condición y material.

```{r matriz de contrastes}
cont.matrix <- makeContrasts(
  WvsE.CTRL = CTRL.WASH - CTRL.ELUTED,
  WvsE.ASD = ASD.WASH - ASD.ELUTED,
  INT = (CTRL.WASH - CTRL.ELUTED) - (ASD.WASH - ASD.ELUTED),
  levels = designMat)
```

```{r estimacion del modelo}
fit <- lmFit(eset_filtered, designMat)
fit.main <- contrasts.fit(fit, cont.matrix)
fit.main <- eBayes(fit.main)
```

## Anotación de las listas de genes

A continuación presentamos una muestra de las listas de genes diferencialmente expresados para cada comparación, incluyendo el símbolo y nombre de cada gen, ordenados por p-valor ajustado.

```{r topTab lists WvsE.CTRL}
topTab_WvsE.CTRL <- topTable(fit.main, number=nrow(fit.main), coef="WvsE.CTRL",
                              adjust="fdr")
```

```{r topTab lists WvsE.ASD}
topTab_WvsE.ASD <- topTable(fit.main, number=nrow(fit.main), coef="WvsE.ASD",
                              adjust="fdr")
```

```{r topTab lists INT}
topTab_INT <- topTable(fit.main, number=nrow(fit.main), coef="INT",
                              adjust="fdr")
```

```{r anotar toptables}
# Generate table from GPL with columns of interest
geneAnots <- gpl_table[, c("ID", "Gene.Title", "Gene.Symbol", "Entrez.Gene")]

anottopTap <- function(x){
  annotated <- merge(geneAnots, x, by.x = "ID", by.y = 0)
  # Sort by adjusted p.value
  annotated <- annotated[order(annotated$adj.P.Val), ]
  # Delete row names
  rownames(annotated) <- NULL
  return (annotated)
}

anotopTab_WvsE.CTRL <- anottopTap(topTab_WvsE.CTRL)
anotopTab_WvsE.ASD <- anottopTap(topTab_WvsE.ASD)
anotopTab_INT <- anottopTap(topTab_INT)
```
### Comparación 1 (WvsE.CTRL): Genes diferencialmente expresados con colas poli-A cortas (WASH) frente a colas poli-A largas (ELUTED) en sujetos control (CTRL).

```{r sample annotated WvsE.CTRL}
print(anotopTab_WvsE.CTRL[, c("Gene.Title", "Gene.Symbol", "logFC", "adj.P.Val")],
     row.names = FALSE)
write.csv2(anotopTab_WvsE.CTRL, file = "results/anotopTab_WvsE.CTRL.csv", row.names = FALSE)
```

### Comparación 2 (WvsE.ASD): Genes diferencialmente expresados con colas poli-A cortas (WASH) frente a colas poli-A largas (ELUTED) en sujetos autistas (ASD).
```{r sample annotated WvsE.ASD}
print(anotopTab_WvsE.ASD[, c("Gene.Title", "Gene.Symbol", "logFC", "adj.P.Val")],
     row.names = FALSE)
write.csv2(anotopTab_WvsE.ASD, file = "results/anotopTab_WvsE.ASD.csv", row.names = FALSE)
```

### Comparación 3 (INT): Genes que cambian su expresión de forma significativa por interacción entre la condición del sujeto (CONTROL, ASD) y el material examinado (WASH, ELUTED).
```{r sample annotated INT}
print(anotopTab_INT[, c("Gene.Title", "Gene.Symbol", "logFC", "adj.P.Val")],
     row.names = FALSE)
```

### Visualización (volcanoplots)

Para una visualización de los datos elegimos las gráficas conocidas como volcanoplots. Cada gen está representado por un punto, con los cambios de expresión en el eje de abcisas y los p-valores ajustados en el eje de ordenadas. Se muestra en cada gráfica el nombre de los 5 genes más significativos. La línea roja horizontal corresponde al p-valor = 0.05.
```{r volcanoplots, fig.height=12, fig.width=5}
par(mfrow=c(3, 1))

contrastes <- colnames(fit.main$coefficients)

for (contrast in 1:length(contrastes)){
  volcanoplot(fit.main, 
              coef = contrastes[contrast],
              highlight = 5, 
              names = eval(str2expression(
                paste0("anotopTab_", contrastes[contrast], "$Gene.Symbol"))),
              main=paste("Genes diferencialmente expresados", contrastes[contrast],
                         sep = "\n"))
abline(v=c(-1,1))
abline(h=-log10(0.05), col="red")
}
```

Sólo examinando las gráficas podemos ver que no tiene sentido examinar los resultados de la comparación por interacción (INT), ya que apenas hay genes con expresión diferencial significativa; y estos, con sólo pequeñas diferencias de expresión.

Sí que son aparentes en cambio las diferencias de expresión significativas en las comparaciones entre "Wash" y "Eluted", aunque sólo con éstas no obtenemos respuesta a la pregunta de si hay diferencias entre "Control" y "ASD". Esto lo exploraremos en los siguientes apartados.

### Comparaciones múltiples
¿Qué genes cambian simultáneamente en más de una comparación? ¿Cuáles son exclusivos de una comparación?
```{r decidetests}
# as many columns as comparisons and as many rows as genes.
res <- decideTests(fit.main, method="separate", adjust.method="fdr", p.value=0.1,
                   lfc = 0)
# This table can be annotated and saved as a csv file, for example
```

En la tabla de comparaciones múltiples, cada gen sobreexpresado está marcado con un 1, un 0 si no hay cambio significativo o un -1 si está downregulado.

Resumen de los resultados:
```{r resumen comparaciones multiples}
sum.res.rows <- apply(abs(res), 1, sum)
res.selected <- res[sum.res.rows!=0, ]
print(summary(res))
```

#### Venn Diagram
```{r venn diagram, fig.height=4.5, fig.width=4.5}
vennDiagram(res.selected[, 1:2], cex=0.9)
title("Genes en común entre dos comparaciones\n Seleccionados con FDR <0.1",
      cex.main=0.9)
```

A partir del diagrama de Venn, vemos que 223 genes están diferencialmente expresados sólo en las muestras Control, y 627 sólo en las muestras ASD. Son estos dos grupos de genes los que exploraremos para investigar las diferencias entre los grupos Control y ASD.

Otro grupo de genes interesantes serían aquellos cuyo perfil de up/down regulación cambia en muestras de sujetos control y sujetos ASD.

Estos grupos son los que marcarán nuestra lista definitiva de genes de interés.

```{r lista definitiva interes}
# Solo nos interesan aquellos genes que:
## estan up o down regulados solo en uno de los grupos
## estan up en un grupo y down en el otro
dif.res.rows <- apply(res.selected, 1, function(x) {x[1] == x[2]})
res.selected2 <- res.selected[dif.res.rows == FALSE, ]
print(summary(res.selected2[, 1:2]))

```

```{r venn diagram lista interes, fig.height=4.5, fig.width=4.5}
vennDiagram(res.selected2[, 1:2], cex=0.9)
title("Genes en común entre dos comparaciones\n Seleccionados con FDR <0.1",
      cex.main=0.9)
```

En resumen, encontramos 223 genes exclusivamente en sujetos Control cuyos ARNm tienen colas diferencialmente largas o cortas.
Encontramos 627 genes exclusivamente en sujetos ASD cuyos ARNm tienen colas diferencialmente largas o cortas.
Ningún gen con diferenciación invertida entre comparaciones.
```{r tablas listas genes exclusivos}
write.csv2(geneAnots[geneAnots$ID %in% rownames(res.selected2), ],
           file = "results/common-differential-genes.csv", row.names = FALSE)
# Genes diferenciales exclusivos del grupo Control
res.control <- res.selected2[(res.selected2[,1] != 0) == TRUE, ]
write.csv2(geneAnots[geneAnots$ID %in% rownames(res.control), ],
           file = "results/control-differential-genes.csv", row.names = FALSE)
# Genes diferenciales exclusivos del grupo ASD
res.ASD <- res.selected2[(res.selected2[,2] != 0) == TRUE, ]
write.csv2(geneAnots[geneAnots$ID %in% rownames(res.ASD), ],
           file = "results/ASD-differential-genes.csv", row.names = FALSE)
```



#### Visualización de perfiles de expresión mediante heatmap
```{r seleccion genes para visualizacion perfiles expresion lista interes}
probesInHeatmap <- rownames(res.selected2)
HMdata <- eset_filtered[rownames(eset_filtered) %in% probesInHeatmap, ]
HMdata <- merge(HMdata, geneAnots[, c("ID", "Gene.Symbol")], by.x=0, by.y="ID")
rownames(HMdata) <- HMdata$Gene.Symbol
HMdata[, c("Row.names", "Gene.Symbol")] <- NULL
colnames(HMdata) <- my.targets$X.Abreviado
no_input_labels <- grep("INPUT", array_labels, value=TRUE, invert = TRUE)
HMdata <- HMdata[, no_input_labels]
```
```{r}
#Colores para ColSideColors:
colsidecolors <- c("orange", "red", 
  "orange", "red", "blue",
  "green", "blue",    "green", 
  "orange", "red", 
 "orange", "red", "blue",   
 "green",  "blue",    "green", 
 "blue",    "green" )
```
```{r Generate heatmap with clustering}
paleta <- colorRampPalette(c("blue", "red"))(n = 299)
library(gplots)

heatmap.2(as.matrix(HMdata),
          Rowv = TRUE,
          Colv = TRUE,
          dendrogram = "both",
          main = "Genes diferencialmente expresados \n FDR < 0.1",
          scale = "row",
          col = paleta,
          sepcolor = "white",
          sepwidth = c(0.05, 0.05),
          cexRow = 0.5,
          cexCol = 0.7,
          key = TRUE,
          keysize = 1.5,
          density.info = "histogram",
          ColSideColors = colsidecolors,
          tracecol = NULL,
          srtCol = 30)
```

Los mapas de calor (heatmaps) pueden servir para agrupar muestras y genes por similaridad en los patrones de expresión. En este caso, para simplificar, hemos eliminado las muestras del grupo "Input", que no nos están ofreciendo información útil.

Al igual que ocurría al examinar los componentes principales y el dendrograma, las muestras se agrupan sobre todo por material ("Wash" y "Eluted"). Dentro del grupo "Wash", sí que parece haber una separación entre "Control" y "ASD" (derecha del gráfico).

Clave de color para las muestras:
Control-Wash: naranja ASD-Wash: azul
Control-Eluted: rojo ASD-Eluted: verde


# Significatividad biológica

Usaremos _clusterProfiler_ para esta parte del informe.

En primer lugar preparamos la lista de genes a analizar:
```{r lista para significatividad biologica}

# Vector of EntrezIDs from the list of genes of interest (probesInHeatmap)
geneList <- geneAnots[geneAnots$ID %in% probesInHeatmap, 4]
universe <- nondup_probes$Entrez.Gene
```
```{r test de sobrerrepresentacion}
library(clusterProfiler)
library(org.Hs.eg.db)
# As universe, I will use all genes represented in the microarray
# before filtering by IQR
ego <- enrichGO(gene = geneList,
                universe = universe,
                OrgDb = org.Hs.eg.db,
                ont = "BP",
                pAdjustMethod = "BH",
                pvalueCutoff = 0.01,
                qvalueCutoff = 0.05,
                readable = TRUE)

save(ego, file="intermediateResults/ego.RData")
```

# Notas

[^1]: En estos casos, se ha comparado la variabilidad de los datos de cada sonda y se ha conservado sólo aquella con una mayor variabilidad entre muestras.

[^2]: En concreto, se trata de sondas que en la tabla de anotaciones están asociadas a más de una identificación Entrez. Puede ser interesante averiguar por qué ocurre esto; pueden explicarse por secuencias pertenecientes a familias génicas muy cercanas, pseudogenes, o por pertenecer a transcritos que 'corran' a lo largo de varios genes. En este caso, sin embargo, debido limitaciones de tiempo, nos hemos limitado a eliminar de la lista aquellas sondas que pueden identificar más de un gen.

[^3]: El criterio para eliminar sondas el análisis ha sido excluir aquellas sondas cuyo rango intercuartílico (IQR) estaba por debajo de la mediana del total de sondas.

# Apéndice A: Reproducibilidad
```{r session_info, include=TRUE, echo=TRUE, results='markup'}
sessionInfo() # For better reproducibility
```








